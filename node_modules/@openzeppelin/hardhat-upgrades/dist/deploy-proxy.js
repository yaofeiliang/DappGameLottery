"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDeployProxy = void 0;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const proxy_factory_1 = require("./proxy-factory");
const validations_1 = require("./validations");
const deploy_1 = require("./utils/deploy");
function makeDeployProxy(hre) {
    return async function deployProxy(ImplFactory, args = [], opts = {}) {
        if (!Array.isArray(args)) {
            opts = args;
            args = [];
        }
        const { provider } = hre.network;
        const validations = await validations_1.readValidations(hre);
        const unlinkedBytecode = upgrades_core_1.getUnlinkedBytecode(validations, ImplFactory.bytecode);
        const version = upgrades_core_1.getVersion(unlinkedBytecode, ImplFactory.bytecode);
        upgrades_core_1.assertUpgradeSafe(validations, version, opts);
        const impl = await upgrades_core_1.fetchOrDeploy(version, provider, async () => {
            const deployment = await deploy_1.deploy(ImplFactory);
            const layout = upgrades_core_1.getStorageLayout(validations, version);
            return { ...deployment, layout };
        });
        const AdminFactory = await proxy_factory_1.getProxyAdminFactory(hre, ImplFactory.signer);
        const adminAddress = await upgrades_core_1.fetchOrDeployAdmin(provider, () => deploy_1.deploy(AdminFactory));
        const data = getInitializerData(ImplFactory, args, opts.initializer);
        const ProxyFactory = await proxy_factory_1.getProxyFactory(hre, ImplFactory.signer);
        const proxy = await ProxyFactory.deploy(impl, adminAddress, data);
        const inst = ImplFactory.attach(proxy.address);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore Won't be readonly because inst was created through attach.
        inst.deployTransaction = proxy.deployTransaction;
        return inst;
    };
    function getInitializerData(ImplFactory, args, initializer) {
        if (initializer === false) {
            return '0x';
        }
        const allowNoInitialization = initializer === undefined && args.length === 0;
        initializer = initializer !== null && initializer !== void 0 ? initializer : 'initialize';
        try {
            const fragment = ImplFactory.interface.getFunction(initializer);
            return ImplFactory.interface.encodeFunctionData(fragment, args);
        }
        catch (e) {
            if (e instanceof Error) {
                if (allowNoInitialization && e.message.includes('no matching function')) {
                    return '0x';
                }
            }
            throw e;
        }
    }
}
exports.makeDeployProxy = makeDeployProxy;
//# sourceMappingURL=deploy-proxy.js.map